rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function signedIn() { return request.auth != null; }
    // Custom claims (e.g. `role`) may be missing on freshly-issued ID tokens until a refresh.
    // Use map.get() to avoid hard failures when the key is absent.
    function role() { return signedIn() ? request.auth.token.get('role', 'unassigned') : 'unassigned'; }
    function isAdmin() { return role() == 'admin'; }
    function isArtist() { return role() == 'artist'; }
    function isCreator() { return role() == 'creator'; }
    function isSelf(uid) { return signedIn() && request.auth.uid == uid; }

    // Public SEO projections (read-only)
    match /handles/{handle} {
      allow read: if true;
      allow write: if false;
    }

    match /publicProfiles/{uid} {
      allow read: if true;
      allow write: if false;
    }

    match /publicPosts/{postId} {
      allow read: if true;
      allow write: if false;
    }

    match /publicCampaigns/{campaignId} {
      allow read: if true;
      allow write: if false;
    }

    function isApprovedFollowerOf(authorUid) {
      return signedIn() &&
        exists(/databases/$(database)/documents/follows/$(authorUid)/followers/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/follows/$(authorUid)/followers/$(request.auth.uid)).data.status == 'approved';
    }

    function canReadPostData(post) {
      // "Hidden" private content: non-approved viewers should not be able to read/see existence.
      // Note: Firestore rules functions must be pure expressions (no imperative `if`).
      return isAdmin() || (
        post != null &&
        post.keys().hasAll(['authorUid', 'visibility', 'authorIsPrivateAccount']) &&
        post.get('deletedAt', null) == null &&
        (
          // Author always can read.
          (signedIn() && request.auth.uid == post.authorUid) ||
          (
            // Account privacy acts as an upper bound: private accounts are follower-only for everyone else.
            post.authorIsPrivateAccount == true
              ? (post.visibility != 'private' && isApprovedFollowerOf(post.authorUid))
              : (
                // Post-level visibility (only applies if account is not private)
                post.visibility == 'public' ||
                (post.visibility == 'followers' && isApprovedFollowerOf(post.authorUid))
              )
          )
        )
      );
    }

    match /posts/{postId} {
      allow read: if canReadPostData(resource.data);
      allow write: if false; // functions only

      match /comments/{commentId} {
        allow read: if exists(/databases/$(database)/documents/posts/$(postId)) &&
          canReadPostData(get(/databases/$(database)/documents/posts/$(postId)).data);
        allow write: if false; // functions only
      }

      match /likes/{uid} {
        allow read: if exists(/databases/$(database)/documents/posts/$(postId)) &&
          canReadPostData(get(/databases/$(database)/documents/posts/$(postId)).data);
        allow write: if false; // functions only
      }
    }

    // Social media metadata (server-controlled; clients fetch via proxy endpoint, not by reading this collection directly).
    match /mediaUploads/{uploadId} {
      allow read, write: if false;
    }

    match /mediaAssets/{assetId} {
      allow read, write: if false;
    }

    // Followers graph (read limited to parties/admin; no direct writes)
    match /follows/{targetUid}/followers/{followerUid} {
      allow read: if isAdmin() || (signedIn() && (request.auth.uid == targetUid || request.auth.uid == followerUid));
      allow write: if false;
    }

    match /following/{followerUid}/targets/{targetUid} {
      allow read: if isAdmin() || (signedIn() && (request.auth.uid == followerUid || request.auth.uid == targetUid));
      allow write: if false;
    }

    match /blocks/{uid}/blocked/{targetUid} {
      allow read: if signedIn() && request.auth.uid == uid;
      allow write: if false;
    }

    match /mutes/{uid}/muted/{targetUid} {
      allow read: if signedIn() && request.auth.uid == uid;
      allow write: if false;
    }

    match /users/{uid} {
      allow read: if isSelf(uid) || isAdmin();
      allow create: if false; // created by auth trigger
      allow update: if isAdmin(); // role/status managed by functions
      allow delete: if false;
    }

    match /artistProfiles/{uid} {
      allow read: if signedIn();
      allow create: if false;
      // Client profile edits must go through callable functions (server-side validation).
      // This prevents self-mutation of sensitive fields like ratings, verification status, etc.
      allow update: if false;
      allow delete: if false;
    }

    match /artistPrivate/{uid} {
      allow read, write: if false; // functions only
    }

    match /creatorProfiles/{uid} {
      allow read: if signedIn();
      allow create: if false;
      // Client profile edits must go through callable functions (server-side validation).
      // This prevents self-mutation of sensitive fields like ratings, verification status, etc.
      allow update: if false;
      allow delete: if false;
    }

    match /creatorPrivate/{uid} {
      allow read, write: if false; // functions only
    }

    match /tracks/{trackId} {
      allow read: if signedIn();
      allow create, update, delete: if false; // functions only
    }

    match /trackPrivate/{trackId} {
      allow read, write: if false; // functions only
    }

    match /campaigns/{campaignId} {
      allow read: if signedIn();
      allow create, update, delete: if false; // functions only
    }

    match /offers/{offerId} {
      allow read: if signedIn() && (
        (isCreator() && resource.data.creatorUid == request.auth.uid) ||
        (isArtist() && resource.data.artistUid == request.auth.uid) ||
        isAdmin()
      );
      allow create, update, delete: if false; // functions only
    }

    match /contracts/{contractId} {
      allow read: if signedIn() && (
        resource.data.artistUid == request.auth.uid ||
        resource.data.creatorUid == request.auth.uid ||
        isAdmin()
      );
      allow write: if false; // functions only
    }

    match /deliverables/{deliverableId} {
      allow read: if signedIn() && (
        resource.data.artistUid == request.auth.uid ||
        resource.data.creatorUid == request.auth.uid ||
        isAdmin()
      );
      allow write: if false; // functions only
    }

    match /threads/{threadId} {
      allow read: if signedIn() && (
        resource.data.participants.hasAny([request.auth.uid]) ||
        isAdmin()
      );
      allow create, update, delete: if false; // functions only

      match /messages/{messageId} {
        allow read: if signedIn() && (
          get(/databases/$(database)/documents/threads/$(threadId)).data.participants.hasAny([request.auth.uid]) ||
          isAdmin()
        );
        allow write: if false; // functions only
      }
    }

    match /notifications/{notificationId} {
      allow read: if signedIn() && (resource.data.toUid == request.auth.uid || isAdmin());
      allow write: if false; // functions only
    }

    match /disputes/{disputeId} {
      allow read: if signedIn() && (
        resource.data.artistUid == request.auth.uid ||
        resource.data.creatorUid == request.auth.uid ||
        isAdmin()
      );
      allow write: if false; // functions only
    }

    match /reviews/{reviewId} {
      allow read: if signedIn();
      allow write: if false; // functions only
    }

    match /auditLogs/{logId} {
      allow read: if isAdmin();
      allow write: if false;
    }

    match /reports/{reportId} {
      allow read: if isAdmin() || (signedIn() && resource.data.reporterUid == request.auth.uid);
      allow write: if false;
    }

    match /stripeEvents/{eventId} {
      allow read, write: if false;
    }

    match /payoutTransfers/{id} {
      allow read: if signedIn() && (
        resource.data.artistUid == request.auth.uid ||
        resource.data.creatorUid == request.auth.uid ||
        isAdmin()
      );
      allow write: if false;
    }
  }
}
